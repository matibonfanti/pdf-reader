<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Advanced PDF ‚Üí AI Voice Reader (Faster OCR)</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1000px;
      margin: 2em auto;
      line-height: 1.6;
      background-color: #f4f7f6;
      color: #333;
      padding: 1em;
    }

    h1 {
      color: #2c3e50;
      text-align: center;
      margin-bottom: 1.5em;
    }

    .control-section {
      background-color: #ffffff;
      padding: 1.5em;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      margin-bottom: 2em;
    }

    label, select, input[type="range"], button {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
      display: block;
      width: 100%;
      box-sizing: border-box;
    }

    input[type="file"] {
      border: 1px solid #ddd;
      padding: 0.75em;
      border-radius: 4px;
      background-color: #f9f9f9;
      margin-bottom: 1em;
    }

    input[type="file"]::file-selector-button {
      margin-right: 10px;
      padding: 0.5em 1em;
      border-radius: 4px;
      border: none;
      background-color: #3498db;
      color: white;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    input[type="file"]::file-selector-button:hover {
      background-color: #2980b9;
    }

    select, input[type="range"] {
      padding: 0.75em;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: white;
    }

    button {
      padding: 0.85em 1.2em;
      border: none;
      border-radius: 4px;
      color: white;
      cursor: pointer;
      transition: background-color 0.2s ease, opacity 0.2s ease;
      font-size: 0.95em;
      margin-top: 0.8em;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    #readBtn { background-color: #27ae60; }
    #readBtn:hover:not(:disabled) { background-color: #229954; }

    #pauseBtn { background-color: #f39c12; }
    #pauseBtn:hover:not(:disabled) { background-color: #e67e22; }

    #resumeBtn { background-color: #3498db; }
    #resumeBtn:hover:not(:disabled) { background-color: #2980b9; }

    #stopBtn { background-color: #e74c3c; }
    #stopBtn:hover:not(:disabled) { background-color: #c0392b; }

    #clearPdfBtn { background-color: #7f8c8d; }
    #clearPdfBtn:hover:not(:disabled) { background-color: #606f70; }


    #previewVoiceBtn {
      background-color: #8e44ad;
      width: auto;
      display: inline-block;
      padding: 0.5em 1em;
      margin-left: 5px;
    }
    #previewVoiceBtn:hover:not(:disabled) { background-color: #732d91; }

    .voice-speed-container {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    .voice-speed-container select {
        flex-grow: 1;
    }


    #status {
      margin: 1.5em 0;
      font-weight: bold;
      padding: 0.75em;
      border-radius: 4px;
      background-color: #e9ecef;
      border-left: 5px solid #3498db;
      min-height: 1.6em;
    }
    #status.error { border-left-color: #e74c3c; background-color: #fadbd8; color: #a93226; }
    #status.success { border-left-color: #27ae60; background-color: #eafaf1; color: #1e8449; }
    #status.processing { border-left-color: #f39c12; background-color: #fef9e7; color: #b9770e; }
    #status.info { border-left-color: #3498db; background-color: #eBF5FB; color: #2874a6;}


    #pdfViewContainer {
      border: 1px solid #ccc;
      width: 100%;
      max-height: 700px;
      overflow-y: auto;
      margin: 1em 0;
      background-color: #e8e8e8;
      padding: 10px;
      box-sizing: border-box;
    }

    #pdfViewContainer canvas {
      display: block;
      margin: 0 auto 15px auto;
      border: 2px solid #bbb;
      max-width: 100%;
      height: auto;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    #pdfViewContainer canvas.currentPageHighlight {
        border-color: #3498db;
        box-shadow: 0 0 15px rgba(52, 152, 219, 0.7);
    }


    .flex-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }

    .column-controls {
      flex: 1;
      min-width: 300px;
    }

    .column-pdf-view {
      flex: 2;
      min-width: 400px;
      display: flex;
      flex-direction: column;
    }

    #speedValue {
      font-weight: bold;
      color: #3498db;
    }

    #controls button {
      margin-right: 0.5em;
      width: auto;
      display: inline-block;
    }
    #controls {
      margin-top: 1em;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5em;
    }
    #controls button {
        flex-grow: 1;
    }
  </style>
</head>
<body>
  <h1>Advanced PDF ‚Üí AI Voice Reader (Faster OCR)</h1>

  <div class="flex-container">
    <div class="column-controls">
      <div class="control-section">
        <h2>Upload & Settings</h2>
        <label for="pdfFileInput">Select PDF File:</label>
        <input type="file" id="pdfFileInput" accept="application/pdf">
        <button id="clearPdfBtn">Clear Current PDF</button>

        <label for="ocrLanguageSelect">OCR Language:</label>
        <select id="ocrLanguageSelect">
            <option value="eng">English</option>
            <option value="spa">Espa√±ol (Spanish)</option>
            <option value="fra">Fran√ßais (French)</option>
        </select>

        <label for="voiceSelect">Voice:</label>
        <div class="voice-speed-container">
            <select id="voiceSelect"></select>
            <button id="previewVoiceBtn" title="Preview selected voice">‚ñ∂</button>
        </div>

        <label for="speedRange">
          Speed: <span id="speedValue">1</span>x
        </label>
        <input type="range" id="speedRange" min="0.5" max="3" step="0.1" value="1">
      </div>

      <div class="control-section">
        <h2>Playback Controls</h2>
        <div id="controls">
          <button id="readBtn">‚ñ∫ Read PDF</button>
          <button id="pauseBtn" disabled>‚ùö‚ùö Pause</button>
          <button id="resumeBtn" disabled>‚ñ∫ Resume</button>
          <button id="stopBtn" disabled>‚ñ† Stop</button>
        </div>
      </div>
    </div>

    <div class="column-pdf-view">
      <div class="control-section">
        <h2>PDF Preview & Status</h2>
        <div id="status">No file selected. Select a PDF and click "Read PDF".</div>
        <div id="pdfViewContainer">
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
  </script>
  <script src="https://unpkg.com/tesseract.js@4.0.2/dist/tesseract.min.js"></script>

  <script>
    const pdfFileInput    = document.getElementById('pdfFileInput');
    const clearPdfBtn     = document.getElementById('clearPdfBtn');
    const statusDiv       = document.getElementById('status');
    const pdfViewContainer= document.getElementById('pdfViewContainer');
    const voiceSelect     = document.getElementById('voiceSelect');
    const previewVoiceBtn = document.getElementById('previewVoiceBtn');
    const speedRange      = document.getElementById('speedRange');
    const speedValue      = document.getElementById('speedValue');
    const ocrLanguageSelect= document.getElementById('ocrLanguageSelect');
    const readBtn         = document.getElementById('readBtn');
    const pauseBtn        = document.getElementById('pauseBtn');
    const resumeBtn       = document.getElementById('resumeBtn');
    const stopBtn         = document.getElementById('stopBtn');

    let voices = [];
    let readingQueue = [];
    let pageChunkMap = [];
    let currentChunkIndex = 0;
    let isReading = false;
    let tesseractScheduler = null; // Changed from tesseractWorker
    const MIN_CHUNK_LENGTH = 3;
    let isRateChangeRestart = false;

    let processedPdfInfo = { filename: null, size: null, numPages: null, lang: null };
    let cachedReadingQueue = [];
    let cachedPageChunkMap = [];
    let currentProcessedPdfDocument = null;

    function updateStatus(message, type = 'info') {
        statusDiv.textContent = message;
        statusDiv.className = type;
    }

    function savePreferences() {
        localStorage.setItem('pdfReaderVoice', voiceSelect.value);
        localStorage.setItem('pdfReaderSpeed', speedRange.value);
        localStorage.setItem('pdfReaderOcrLang', ocrLanguageSelect.value);
    }

    function loadPreferences() {
        const savedVoice = localStorage.getItem('pdfReaderVoice');
        const savedSpeed = localStorage.getItem('pdfReaderSpeed');
        const savedOcrLang = localStorage.getItem('pdfReaderOcrLang');

        if (savedSpeed) {
            speedRange.value = savedSpeed;
            speedValue.textContent = parseFloat(savedSpeed).toFixed(1);
        }
        if (savedOcrLang) {
            ocrLanguageSelect.value = savedOcrLang;
        }
        return { savedVoice };
    }

    async function initializeTesseractScheduler() { // Renamed function
        if (tesseractScheduler) {
            await tesseractScheduler.terminate(); // Terminate existing scheduler
            tesseractScheduler = null;
        }
        
        const numWorkers = Math.min(navigator.hardwareConcurrency || 2, 4); // Use up to 4 workers
        updateStatus(`Initializing OCR engine with ${numWorkers} worker(s)...`, 'processing');
        
        try {
            tesseractScheduler = Tesseract.createScheduler();
            const workerPromises = [];
            for (let i = 0; i < numWorkers; i++) {
                const worker = await Tesseract.createWorker(); // Default logger (console)
                await worker.loadLanguage(ocrLanguageSelect.value);
                await worker.initialize(ocrLanguageSelect.value);
                // Example: Set a common parameter for all workers if needed
                // await worker.setParameters({
                //   tessedit_pageseg_mode: '3', // PSM_AUTO, usually good for structured docs
                // });
                tesseractScheduler.addWorker(worker);
            }
            updateStatus(`OCR engine ready with ${numWorkers} worker(s).`, 'success');
        } catch (error) {
            console.error("Error initializing Tesseract scheduler:", error);
            updateStatus(`Error initializing OCR: ${error.message}`, 'error');
            tesseractScheduler = null;
        }
    }


    function populateVoices() {
        try {
            voices = speechSynthesis.getVoices();
            const { savedVoice } = loadPreferences();
            voiceSelect.innerHTML = '';

            if (voices.length === 0) {
                const opt = document.createElement('option');
                opt.textContent = "No voices found in browser";
                opt.disabled = true;
                voiceSelect.appendChild(opt);
                previewVoiceBtn.disabled = true;
                readBtn.disabled = true;
                updateStatus('No voices found. Speech synthesis may not be available.', 'error');
                return;
            }

            previewVoiceBtn.disabled = false;
            readBtn.disabled = !(pdfFileInput.files && pdfFileInput.files.length > 0);

            const groupedVoices = voices.reduce((acc, voice) => {
                const langPrefix = voice.lang.split('-')[0].toLowerCase();
                if (!acc[langPrefix]) acc[langPrefix] = [];
                acc[langPrefix].push(voice);
                return acc;
            }, {});

            const currentOcrLangPrefix = ocrLanguageSelect.value.substring(0, 2).toLowerCase();
            const sortedLangGroups = Object.keys(groupedVoices).sort((a, b) => {
                if (a === currentOcrLangPrefix && b !== currentOcrLangPrefix) return -1;
                if (b === currentOcrLangPrefix && a !== currentOcrLangPrefix) return 1;
                if (a === 'en' && b !== 'en') return -1;
                if (b === 'en' && a !== 'en') return 1;
                return a.localeCompare(b);
            });

            let voiceFoundAndSet = false;
            sortedLangGroups.forEach(langPrefix => {
                const optgroup = document.createElement('optgroup');
                let langDisplayName = langPrefix.toUpperCase();
                try {
                    langDisplayName = new Intl.DisplayNames([navigator.language || 'en'], { type: 'language' }).of(langPrefix) || langPrefix.toUpperCase();
                } catch (e) { /* Use prefix */ }
                
                optgroup.label = `--- ${langDisplayName} Voices ---`;
                groupedVoices[langPrefix].sort((a,b) => a.name.localeCompare(b.name)).forEach(v => {
                    const opt = document.createElement('option');
                    opt.value = v.name;
                    opt.textContent = `${v.name} (${v.lang})${v.localService ? ' - Local' : ''}`;
                    opt.setAttribute('data-lang', v.lang);
                    if (savedVoice && v.name === savedVoice) {
                        opt.selected = true;
                        voiceFoundAndSet = true;
                    }
                    optgroup.appendChild(opt);
                });
                voiceSelect.appendChild(optgroup);
            });

            if (!voiceFoundAndSet && voiceSelect.options.length > 0) {
                let preferredOption = Array.from(voiceSelect.options).find(opt => {
                    if(opt.disabled) return false;
                    const optLang = opt.getAttribute('data-lang').substring(0,2).toLowerCase();
                    return optLang === currentOcrLangPrefix || optLang === 'en';
                });
                if (preferredOption) preferredOption.selected = true;
                else {
                    const firstEnabledOption = Array.from(voiceSelect.options).find(opt => !opt.disabled);
                    if(firstEnabledOption) firstEnabledOption.selected = true;
                }
            }
            
            if(voiceSelect.options.length === 0 || Array.from(voiceSelect.options).every(opt => opt.disabled)) {
                if(!voiceSelect.querySelector('option[disabled]')) {
                    const opt = document.createElement('option');
                    opt.textContent = "No voices available";
                    opt.disabled = true;
                    voiceSelect.appendChild(opt);
                }
                readBtn.disabled = true;
                previewVoiceBtn.disabled = true;
            }

        } catch (error) {
            console.error("Error populating voices:", error);
            updateStatus('Could not load voices. Speech synthesis might not be supported.', 'error');
            previewVoiceBtn.disabled = true;
            readBtn.disabled = true;
        }
    }

    document.addEventListener('DOMContentLoaded', async () => {
        loadPreferences();
        if (typeof speechSynthesis === 'undefined') {
            updateStatus('Speech Synthesis API is not supported. PDF reading is unavailable.', 'error');
            [previewVoiceBtn, speedRange, readBtn, pauseBtn, resumeBtn, stopBtn, voiceSelect, ocrLanguageSelect, clearPdfBtn, pdfFileInput].forEach(el => el.disabled = true);
            return;
        }
        
        populateVoices();
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = populateVoices;
        }
        setTimeout(populateVoices, 500); 
        setTimeout(populateVoices, 1500);

        await initializeTesseractScheduler();

        readBtn.disabled = !pdfFileInput.files || !pdfFileInput.files[0];
        clearPdfBtn.disabled = !pdfFileInput.files || !pdfFileInput.files[0];
    });

    pdfFileInput.addEventListener('change', () => {
        const hasFile = pdfFileInput.files && pdfFileInput.files.length > 0;
        readBtn.disabled = !hasFile;
        clearPdfBtn.disabled = !hasFile;
        if (hasFile) {
            updateStatus(`File "${pdfFileInput.files[0].name}" selected. Click "Read PDF".`);
            resetReadingState(true, true);
        } else {
            updateStatus('No file selected. Select a PDF and click "Read PDF".');
            resetReadingState(true, true);
        }
    });
    
    ocrLanguageSelect.addEventListener('change', async () => {
        savePreferences();
        resetReadingState(true, true); // OCR lang change invalidates cache & scheduler
        await initializeTesseractScheduler(); // Re-initialize scheduler with new language
        populateVoices();
    });

    clearPdfBtn.addEventListener('click', () => {
        pdfFileInput.value = '';
        resetReadingState(true, true);
        updateStatus('PDF cleared. Select a new PDF file.');
        readBtn.disabled = true;
        clearPdfBtn.disabled = true;
    });

    function resetReadingState(fullResetVisuals = true, clearCache = false) {
        speechSynthesis.cancel();
        isReading = false;
        isRateChangeRestart = false; 
        readingQueue = [];
        pageChunkMap = [];
        currentChunkIndex = 0;
        
        if (clearCache) {
            processedPdfInfo = { filename: null, size: null, numPages: null, lang: null };
            cachedReadingQueue = [];
            cachedPageChunkMap = [];
            currentProcessedPdfDocument = null;
            console.log("OCR Cache cleared.");
        }

        if (fullResetVisuals) {
            pdfViewContainer.innerHTML = '';
            if(!clearCache && currentProcessedPdfDocument) {
                // Retain currentProcessedPdfDocument if not clearing cache
            } else {
                 currentProcessedPdfDocument = null;
            }
        }
        
        pauseBtn.disabled = true;
        resumeBtn.disabled = true;
        stopBtn.disabled = true;
        readBtn.disabled = !(pdfFileInput.files && pdfFileInput.files.length > 0);
        // Enable clear button if there's a file selected or content in view
        const fileSelected = pdfFileInput.files && pdfFileInput.files.length > 0;
        clearPdfBtn.disabled = ! (fileSelected || pdfViewContainer.innerHTML !== '');


        removePageHighlight();
    }

    speedRange.addEventListener('input', () => {
        speedValue.textContent = parseFloat(speedRange.value).toFixed(1);
        savePreferences();

        if (isReading && (speechSynthesis.speaking || speechSynthesis.paused)) {
             if (speechSynthesis.speaking) { // Only act if actively speaking
                isRateChangeRestart = true; 
                speechSynthesis.cancel(); 
            }
            // If paused, new rate will apply when next chunk is initiated by resume->speakNextChunk sequence
        }
    });
    voiceSelect.addEventListener('change', savePreferences);


    previewVoiceBtn.addEventListener('click', () => {
      const selectedOption = voiceSelect.options[voiceSelect.selectedIndex];
      if (!selectedOption || !selectedOption.value || selectedOption.disabled) {
        updateStatus('Please select an available voice first.', 'error'); return;
      }
      speechSynthesis.cancel();
      try {
        const preview = new SpeechSynthesisUtterance('This is a preview of the selected voice at the current speed.');
        preview.voice = voices.find(v => v.name === selectedOption.value);
        if (!preview.voice) {
            updateStatus('Selected voice for preview not found. Try another.', 'error'); return;
        }
        preview.lang = preview.voice.lang;
        preview.rate  = parseFloat(speedRange.value);
        preview.onerror = (event) => {
            console.error('SpeechSynthesisUtterance error:', event.error);
            updateStatus(`Error previewing voice: ${event.error}`, 'error');
        };
        speechSynthesis.speak(preview);
      } catch (error) {
          console.error("Error in voice preview:", error);
          updateStatus(`Could not preview voice: ${error.message}`, 'error');
      }
    });

    async function renderAllPdfPages(pdfDoc, container) {
        updateStatus('Rendering PDF pages...', 'processing');
        container.innerHTML = '';
        const numPages = pdfDoc.numPages;
        const pageRenderPromises = [];

        for (let i = 1; i <= numPages; i++) {
            pageRenderPromises.push(
                pdfDoc.getPage(i).then(page => {
                    const viewport = page.getViewport({ scale: 1.5 });
                    const pageCanvas = document.createElement('canvas');
                    pageCanvas.id = `pdfPageCanvas-${i}`;
                    pageCanvas.width = viewport.width;
                    pageCanvas.height = viewport.height;
                    pageCanvas.style.maxWidth = "100%";
                    // Note: Canvases need to be appended in order, so this part is tricky with Promise.all
                    // For simplicity, we'll append them after all are created if order matters, or render sequentially.
                    // Let's render and append sequentially for guaranteed order.
                    return {canvas: pageCanvas, context: pageCanvas.getContext('2d'), viewport: viewport, page: page, pageNum: i};
                })
            );
        }
        
        const pageInfos = await Promise.all(pageRenderPromises);
        // Sort by pageNum to ensure correct order for appending
        pageInfos.sort((a,b) => a.pageNum - b.pageNum); 

        for(const info of pageInfos) {
            container.appendChild(info.canvas);
            await info.page.render({ canvasContext: info.context, viewport: info.viewport }).promise;
        }
        updateStatus('PDF pages rendered.', 'success');
    }


    readBtn.addEventListener('click', async () => {
        const file = pdfFileInput.files[0];
        if (!file) {
            updateStatus('üö´ Please select a PDF first.', 'error'); return;
        }
        const selectedVoiceOption = voiceSelect.options[voiceSelect.selectedIndex];
        if (!selectedVoiceOption || !selectedVoiceOption.value || selectedVoiceOption.disabled) {
            updateStatus('üö´ Please select an available voice.', 'error'); return;
        }
        if (!tesseractScheduler) { // Check scheduler
            updateStatus('üö´ OCR engine not initialized. Please wait or refresh.', 'error');
            await initializeTesseractScheduler();
            if (!tesseractScheduler) return;
        }

        isReading = false;
        speechSynthesis.cancel();
        currentChunkIndex = 0;

        readBtn.disabled = true;
        clearPdfBtn.disabled = true;
        pauseBtn.disabled = true;
        resumeBtn.disabled = true;
        stopBtn.disabled = true;

        if (currentProcessedPdfDocument &&
            processedPdfInfo.filename === file.name &&
            processedPdfInfo.size === file.size &&
            processedPdfInfo.lang === ocrLanguageSelect.value &&
            cachedReadingQueue.length > 0) {

            readingQueue = [...cachedReadingQueue];
            pageChunkMap = [...cachedPageChunkMap];
            
            if (pdfViewContainer.childElementCount !== currentProcessedPdfDocument.numPages) {
                await renderAllPdfPages(currentProcessedPdfDocument, pdfViewContainer);
            }
            
            updateStatus('Using cached text. Starting reading‚Ä¶', 'success');
            isReading = true;
            pauseBtn.disabled = false;
            stopBtn.disabled  = false;
            clearPdfBtn.disabled = false;
            speakNextChunk();
            return;
        }

        resetReadingState(true, true); // Full visual reset and clear any old cache
        updateStatus('Loading PDF‚Ä¶', 'processing');

        try {
            const data = await file.arrayBuffer();
            currentProcessedPdfDocument = await pdfjsLib.getDocument({ data }).promise;
            const numPages = currentProcessedPdfDocument.numPages;

            updateStatus(`Found ${numPages} page(s). Rendering pages...`, 'processing');
            pdfViewContainer.innerHTML = '';
            
            const ocrJobs = [];
            const pageCanvases = []; // To hold references to canvases for OCR

            // First pass: Render all pages and prepare canvases
            for (let i = 1; i <= numPages; i++) {
                const page = await currentProcessedPdfDocument.getPage(i);
                const viewport = page.getViewport({ scale: 1.5 }); // Or make scale configurable
                const pageCanvas = document.createElement('canvas');
                pageCanvas.id = `pdfPageCanvas-${i}`;
                const pageCtx = pageCanvas.getContext('2d', { willReadFrequently: true });
                
                pageCanvas.width = viewport.width;
                pageCanvas.height = viewport.height;
                pageCanvas.style.maxWidth = "100%";
                pdfViewContainer.appendChild(pageCanvas); // Append canvas to DOM
                
                await page.render({ canvasContext: pageCtx, viewport: viewport }).promise;
                pageCanvases.push(pageCanvas); // Store for OCR job

                if (i === 1 && pageCanvas.scrollIntoView) pageCanvas.scrollIntoView({ behavior: 'auto', block: 'start' });
            }
            
            updateStatus(`All ${numPages} pages rendered. Starting OCR jobs...`, 'processing');

            // Second pass: Create OCR job promises for all rendered canvases
            for (let i = 0; i < numPages; i++) {
                 ocrJobs.push({
                    pageNum: i + 1, // Page numbers are 1-indexed
                    promise: tesseractScheduler.addJob('recognize', pageCanvases[i])
                });
            }

            let ocrCompletedCount = 0;
            const totalOcrJobs = ocrJobs.length;
            updateStatus(`OCRing ${totalOcrJobs} pages... (0/${totalOcrJobs})`, 'processing');

            const ocrResults = await Promise.all(
                ocrJobs.map(job =>
                    job.promise
                        .then(result => {
                            ocrCompletedCount++;
                            updateStatus(`OCRing pages... (${ocrCompletedCount}/${totalOcrJobs})`, 'processing');
                            return { ...result, pageNum: job.pageNum, error: null };
                        })
                        .catch(error => {
                            ocrCompletedCount++;
                            updateStatus(`OCRing pages... (${ocrCompletedCount}/${totalOcrJobs})`, 'processing');
                            console.warn(`OCR failed for page ${job.pageNum}:`, error);
                            return { error, pageNum: job.pageNum, data: {text: ""} }; // Ensure data.text exists
                        })
                )
            );
            
            updateStatus('Processing OCR results...', 'processing');
            readingQueue = []; // Reset before populating
            pageChunkMap = [];

            ocrResults.sort((a,b) => a.pageNum - b.pageNum); // Ensure results are in page order

            for (const result of ocrResults) {
                if (result.error) {
                    // Error already logged, skip this page's text
                    continue;
                }
                const { data: { text }, pageNum } = result;
                const chunks = text.match(new RegExp(`(.|[\\r\\n]){1,250}(?=\\s|$)`, 'g'));
                if (chunks) {
                    chunks.forEach(chunk => {
                    if (chunk.trim().length >= MIN_CHUNK_LENGTH) {
                        readingQueue.push(chunk.trim());
                        pageChunkMap.push(pageNum);
                    }
                    });
                }
            }


            if (!readingQueue.length) {
                updateStatus('‚ö†Ô∏è No text detected or extracted from the PDF after OCR.', 'error');
                readBtn.disabled = false;
                clearPdfBtn.disabled = false;
                currentProcessedPdfDocument = null;
                return;
            }

            cachedReadingQueue = [...readingQueue];
            cachedPageChunkMap = [...pageChunkMap];
            processedPdfInfo = {
                filename: file.name,
                size: file.size,
                numPages: currentProcessedPdfDocument.numPages,
                lang: ocrLanguageSelect.value
            };
            console.log("OCR results cached.");

            updateStatus('Text processed. Starting reading‚Ä¶', 'success');
            isReading = true;
            pauseBtn.disabled = false;
            stopBtn.disabled  = false;
            clearPdfBtn.disabled = false;
            speakNextChunk();

        } catch (error) {
            console.error("Error during PDF processing or OCR:", error);
            updateStatus(`üö´ Error: ${error.message}. Try again.`, 'error');
            resetReadingState(true, true);
            readBtn.disabled = !(pdfFileInput.files && pdfFileInput.files.length > 0);
            // clearPdfBtn state handled by resetReadingState
        }
    });

    function highlightCurrentPage(pageNumber) {
        removePageHighlight();
        const pageCanvas = document.getElementById(`pdfPageCanvas-${pageNumber}`);
        if (pageCanvas) {
            pageCanvas.classList.add('currentPageHighlight');
            if(pageCanvas.scrollIntoViewIfNeeded) pageCanvas.scrollIntoViewIfNeeded({ behavior: 'smooth', block: 'nearest' });
            else if(pageCanvas.scrollIntoView) pageCanvas.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    }

    function removePageHighlight() {
        const highlighted = pdfViewContainer.querySelector('.currentPageHighlight');
        if (highlighted) highlighted.classList.remove('currentPageHighlight');
    }

    function speakNextChunk() {
        removePageHighlight();

        if (isRateChangeRestart) { 
            // Flag will be reset in onend if it was a rate-change initiated cancel
        }

        if (!isReading || currentChunkIndex >= readingQueue.length) {
            const finishedMsg = readingQueue.length > 0 ? '‚úÖ Finished reading PDF.' : 'No text was queued for reading.';
            updateStatus(finishedMsg, 'success');
            isReading = false;
            pauseBtn.disabled = true;
            resumeBtn.disabled = true;
            stopBtn.disabled = true;
            readBtn.disabled = !(pdfFileInput.files && pdfFileInput.files.length > 0);
            clearPdfBtn.disabled = !(pdfFileInput.files && pdfFileInput.files.length > 0 && pdfViewContainer.innerHTML !== '');
            currentChunkIndex = 0;
            return;
        }

        let textToSpeak = readingQueue[currentChunkIndex];
        while (textToSpeak && textToSpeak.trim().length < MIN_CHUNK_LENGTH && currentChunkIndex < readingQueue.length -1) {
            currentChunkIndex++;
            textToSpeak = readingQueue[currentChunkIndex];
        }
        if (!textToSpeak || (textToSpeak.trim().length < MIN_CHUNK_LENGTH && currentChunkIndex >= readingQueue.length -1)) {
            currentChunkIndex++;
            speakNextChunk(); 
            return;
        }

        const currentPageNumber = pageChunkMap[currentChunkIndex];
        highlightCurrentPage(currentPageNumber);

        const utterance = new SpeechSynthesisUtterance(textToSpeak);
        const selectedVoiceOption = voiceSelect.options[voiceSelect.selectedIndex];
        
        if (selectedVoiceOption && selectedVoiceOption.value) {
            utterance.voice = voices.find(v => v.name === selectedVoiceOption.value);
        }
        if (!utterance.voice && voices.length > 0) {
            const ocrLangPrefix = ocrLanguageSelect.value.substring(0,2).toLowerCase();
            utterance.voice = voices.find(v => v.lang.startsWith(ocrLangPrefix)) || voices.find(v => v.lang.startsWith('en')) || voices[0];
        }
        
        utterance.lang = utterance.voice ? utterance.voice.lang : (ocrLanguageSelect.value === 'eng' ? 'en-US' : ocrLanguageSelect.value);
        utterance.rate  = parseFloat(speedRange.value);

        utterance.onstart = () => {
            updateStatus(`Reading chunk ${currentChunkIndex + 1}/${readingQueue.length} (Page ${currentPageNumber})‚Ä¶`, 'processing');
        };

        utterance.onend = () => {
            if (isRateChangeRestart) {
                isRateChangeRestart = false;
                if (isReading) {
                    setTimeout(() => speakNextChunk(), 50);
                }
                return;
            }

            currentChunkIndex++;
            if (isReading) {
                speakNextChunk();
            } else {
                 if (! (currentChunkIndex >= readingQueue.length) ) {
                    updateStatus('Reading stopped by user action.', 'info');
                 }
            }
        };

        utterance.onerror = (event) => {
            console.error('SpeechSynthesisUtterance error:', event.error, "Chunk:", textToSpeak);
            updateStatus(`Speech error: ${event.error}. Skipping.`, 'error');
            currentChunkIndex++;
            if (isReading) speakNextChunk();
        };
        speechSynthesis.speak(utterance);
    }

    pauseBtn.addEventListener('click', () => {
      if (speechSynthesis.speaking && !speechSynthesis.paused) {
        speechSynthesis.pause();
        updateStatus('‚è∏ Paused.', 'processing');
        pauseBtn.disabled = true;
        resumeBtn.disabled= false;
        stopBtn.disabled  = false;
      }
    });

    resumeBtn.addEventListener('click', () => {
      if (speechSynthesis.paused) {
        speechSynthesis.resume();
        updateStatus('‚ñ∂ Resuming‚Ä¶', 'processing');
        const currentPageNumber = pageChunkMap[currentChunkIndex];
        if (currentPageNumber) highlightCurrentPage(currentPageNumber);
        pauseBtn.disabled = false;
        resumeBtn.disabled= true;
      }
    });

    stopBtn.addEventListener('click', () => {
      isReading = false; 
      isRateChangeRestart = false;
      speechSynthesis.cancel();
      updateStatus('‚ñ† Stopped by user.', 'info');
      pauseBtn.disabled = true;
      resumeBtn.disabled = true;
      stopBtn.disabled = true;
      readBtn.disabled = !(pdfFileInput.files && pdfFileInput.files.length > 0);
      const fileSelected = pdfFileInput.files && pdfFileInput.files.length > 0;
      clearPdfBtn.disabled = !(fileSelected || pdfViewContainer.innerHTML !== '');
      currentChunkIndex = 0;
      removePageHighlight();
    });

    window.addEventListener('beforeunload', async () => {
        if (tesseractScheduler) { // Check scheduler
            await tesseractScheduler.terminate();
            tesseractScheduler = null;
        }
        speechSynthesis.cancel();
    });

  </script>
</body>
</html>
