<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Advanced PDF → AI Voice Reader</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1000px;
      margin: 2em auto;
      line-height: 1.6;
      background-color: #f4f7f6;
      color: #333;
      padding: 1em;
    }

    h1 {
      color: #2c3e50;
      text-align: center;
      margin-bottom: 1.5em;
    }

    .control-section {
      background-color: #ffffff;
      padding: 1.5em;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      margin-bottom: 2em;
    }

    label, select, input[type="range"], button {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
      display: block;
      width: 100%;
      box-sizing: border-box;
    }

    input[type="file"] {
      border: 1px solid #ddd;
      padding: 0.75em;
      border-radius: 4px;
      background-color: #f9f9f9;
      margin-bottom: 1em;
    }

    input[type="file"]::file-selector-button {
      margin-right: 10px;
      padding: 0.5em 1em;
      border-radius: 4px;
      border: none;
      background-color: #3498db;
      color: white;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    input[type="file"]::file-selector-button:hover {
      background-color: #2980b9;
    }

    select, input[type="range"] {
      padding: 0.75em;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: white;
    }

    button {
      padding: 0.85em 1.2em;
      border: none;
      border-radius: 4px;
      color: white;
      cursor: pointer;
      transition: background-color 0.2s ease, opacity 0.2s ease;
      font-size: 0.95em;
      margin-top: 0.8em;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    #readBtn { background-color: #27ae60; }
    #readBtn:hover:not(:disabled) { background-color: #229954; }

    #pauseBtn { background-color: #f39c12; }
    #pauseBtn:hover:not(:disabled) { background-color: #e67e22; }

    #resumeBtn { background-color: #3498db; }
    #resumeBtn:hover:not(:disabled) { background-color: #2980b9; }

    #stopBtn { background-color: #e74c3c; }
    #stopBtn:hover:not(:disabled) { background-color: #c0392b; }

    #clearPdfBtn { background-color: #7f8c8d; }
    #clearPdfBtn:hover:not(:disabled) { background-color: #606f70; }


    #previewVoiceBtn {
      background-color: #8e44ad;
      width: auto;
      display: inline-block;
      padding: 0.5em 1em;
      margin-left: 5px;
    }
    #previewVoiceBtn:hover:not(:disabled) { background-color: #732d91; }

    .voice-speed-container {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    .voice-speed-container select {
        flex-grow: 1;
    }


    #status {
      margin: 1.5em 0;
      font-weight: bold;
      padding: 0.75em;
      border-radius: 4px;
      background-color: #e9ecef;
      border-left: 5px solid #3498db;
      min-height: 1.6em;
    }
    #status.error { border-left-color: #e74c3c; background-color: #fadbd8; color: #a93226; }
    #status.success { border-left-color: #27ae60; background-color: #eafaf1; color: #1e8449; }
    #status.processing { border-left-color: #f39c12; background-color: #fef9e7; color: #b9770e; }
    #status.info { border-left-color: #3498db; background-color: #eBF5FB; color: #2874a6;}


    #pdfViewContainer {
      border: 1px solid #ccc;
      width: 100%;
      max-height: 700px;
      overflow-y: auto;
      margin: 1em 0;
      background-color: #e8e8e8;
      padding: 10px;
      box-sizing: border-box;
    }

    #pdfViewContainer canvas {
      display: block;
      margin: 0 auto 15px auto;
      border: 2px solid #bbb;
      max-width: 100%;
      height: auto;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    #pdfViewContainer canvas.currentPageHighlight {
        border-color: #3498db;
        box-shadow: 0 0 15px rgba(52, 152, 219, 0.7);
    }


    .flex-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }

    .column-controls {
      flex: 1;
      min-width: 300px;
    }

    .column-pdf-view {
      flex: 2;
      min-width: 400px;
      display: flex;
      flex-direction: column;
    }

    #speedValue {
      font-weight: bold;
      color: #3498db;
    }

    #controls button {
      margin-right: 0.5em;
      width: auto;
      display: inline-block;
    }
    #controls {
      margin-top: 1em;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5em;
    }
    #controls button {
        flex-grow: 1;
    }
  </style>
</head>
<body>
  <h1>Advanced PDF → AI Voice Reader</h1>

  <div class="flex-container">
    <div class="column-controls">
      <div class="control-section">
        <h2>Upload & Settings</h2>
        <label for="pdfFileInput">Select PDF File:</label>
        <input type="file" id="pdfFileInput" accept="application/pdf">
        <button id="clearPdfBtn">Clear Current PDF</button>

        <label for="ocrLanguageSelect">OCR Language:</label>
        <select id="ocrLanguageSelect">
            <option value="eng">English</option>
            <option value="spa">Español (Spanish)</option>
            <option value="fra">Français (French)</option>
        </select>

        <label for="voiceSelect">Voice:</label> <div class="voice-speed-container">
            <select id="voiceSelect"></select>
            <button id="previewVoiceBtn" title="Preview selected voice">▶</button>
        </div>

        <label for="speedRange">
          Speed: <span id="speedValue">1</span>x
        </label>
        <input type="range" id="speedRange" min="0.5" max="3" step="0.1" value="1">
      </div>

      <div class="control-section">
        <h2>Playback Controls</h2>
        <div id="controls">
          <button id="readBtn">► Read PDF</button>
          <button id="pauseBtn" disabled>❚❚ Pause</button>
          <button id="resumeBtn" disabled>► Resume</button>
          <button id="stopBtn" disabled>■ Stop</button>
        </div>
      </div>
    </div>

    <div class="column-pdf-view">
      <div class="control-section">
        <h2>PDF Preview & Status</h2>
        <div id="status">No file selected. Select a PDF and click "Read PDF".</div>
        <div id="pdfViewContainer">
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
  </script>
  <script src="https://unpkg.com/tesseract.js@4.0.2/dist/tesseract.min.js"></script>

  <script>
    const pdfFileInput    = document.getElementById('pdfFileInput');
    const clearPdfBtn     = document.getElementById('clearPdfBtn');
    const statusDiv       = document.getElementById('status');
    const pdfViewContainer= document.getElementById('pdfViewContainer');
    const voiceSelect     = document.getElementById('voiceSelect');
    const previewVoiceBtn = document.getElementById('previewVoiceBtn');
    const speedRange      = document.getElementById('speedRange');
    const speedValue      = document.getElementById('speedValue');
    const ocrLanguageSelect= document.getElementById('ocrLanguageSelect');
    const readBtn         = document.getElementById('readBtn');
    const pauseBtn        = document.getElementById('pauseBtn');
    const resumeBtn       = document.getElementById('resumeBtn');
    const stopBtn         = document.getElementById('stopBtn');

    let voices = [];
    let readingQueue = [];
    let pageChunkMap = [];
    let currentChunkIndex = 0;
    let isReading = false;
    let currentPdf = null;
    let tesseractWorker = null;
    const MIN_CHUNK_LENGTH = 3;

    function updateStatus(message, type = 'info') {
        statusDiv.textContent = message;
        statusDiv.className = type;
    }

    function savePreferences() {
        localStorage.setItem('pdfReaderVoice', voiceSelect.value);
        localStorage.setItem('pdfReaderSpeed', speedRange.value);
        localStorage.setItem('pdfReaderOcrLang', ocrLanguageSelect.value);
    }

    function loadPreferences() {
        const savedVoice = localStorage.getItem('pdfReaderVoice');
        const savedSpeed = localStorage.getItem('pdfReaderSpeed');
        const savedOcrLang = localStorage.getItem('pdfReaderOcrLang');

        if (savedSpeed) {
            speedRange.value = savedSpeed;
            speedValue.textContent = parseFloat(savedSpeed).toFixed(1);
        }
        if (savedOcrLang) {
            ocrLanguageSelect.value = savedOcrLang;
        }
        return { savedVoice };
    }

    async function initializeTesseractWorker() {
        if (tesseractWorker) {
            await tesseractWorker.terminate();
            tesseractWorker = null;
        }
        updateStatus('Initializing OCR engine...', 'processing');
        try {
            tesseractWorker = await Tesseract.createWorker({
                logger: m => {
                    if (m.status === 'recognizing text') {
                        // console.log(`OCR Progress: ${(m.progress * 100).toFixed(0)}%`);
                    }
                }
            });
            await tesseractWorker.loadLanguage(ocrLanguageSelect.value);
            await tesseractWorker.initialize(ocrLanguageSelect.value);
            updateStatus('OCR engine ready.', 'success');
        } catch (error) {
            console.error("Error initializing Tesseract worker:", error);
            updateStatus(`Error initializing OCR: ${error.message}`, 'error');
            tesseractWorker = null;
        }
    }


    function populateVoices() {
        try {
            voices = speechSynthesis.getVoices(); // Get all voices
            const { savedVoice } = loadPreferences();

            voiceSelect.innerHTML = ''; // Clear previous options

            if (voices.length === 0) {
                const opt = document.createElement('option');
                opt.textContent = "No voices found in browser";
                opt.disabled = true;
                voiceSelect.appendChild(opt);
                previewVoiceBtn.disabled = true;
                readBtn.disabled = true;
                updateStatus('No voices found in your browser. Speech synthesis may not be available.', 'error');
                return;
            }

            previewVoiceBtn.disabled = false;
            readBtn.disabled = !(pdfFileInput.files && pdfFileInput.files.length > 0);

            // Group voices by language prefix (e.g., 'en', 'es')
            const groupedVoices = voices.reduce((acc, voice) => {
                const langPrefix = voice.lang.split('-')[0].toLowerCase(); // 'en-US' -> 'en'
                if (!acc[langPrefix]) {
                    acc[langPrefix] = [];
                }
                acc[langPrefix].push(voice);
                return acc;
            }, {});

            const currentOcrLangPrefix = ocrLanguageSelect.value.substring(0, 2).toLowerCase();
            const sortedLangGroups = Object.keys(groupedVoices).sort((a, b) => {
                if (a === currentOcrLangPrefix && b !== currentOcrLangPrefix) return -1;
                if (b === currentOcrLangPrefix && a !== currentOcrLangPrefix) return 1;
                if (a === 'en' && b !== 'en') return -1;
                if (b === 'en' && a !== 'en') return 1;
                return a.localeCompare(b);
            });

            let voiceFoundAndSet = false;
            sortedLangGroups.forEach(langPrefix => {
                const optgroup = document.createElement('optgroup');
                let langDisplayName = langPrefix.toUpperCase();
                try {
                    // Attempt to get a more human-readable language name
                    langDisplayName = new Intl.DisplayNames([navigator.language || 'en'], { type: 'language' }).of(langPrefix) || langPrefix.toUpperCase();
                } catch (e) { /* Use prefix if DisplayNames fails */ }
                
                optgroup.label = `--- ${langDisplayName} Voices ---`;

                groupedVoices[langPrefix].sort((a,b) => a.name.localeCompare(b.name)).forEach(v => { // Sort voices within language group
                    const opt = document.createElement('option');
                    opt.value = v.name;
                    // Show if it's a local service voice, as they are often higher quality
                    opt.textContent = `${v.name} (${v.lang})${v.localService ? ' - Local (High Quality)' : ''}`;
                    opt.setAttribute('data-lang', v.lang); // Store full lang tag for utterance
                    if (savedVoice && v.name === savedVoice) {
                        opt.selected = true;
                        voiceFoundAndSet = true;
                    }
                    optgroup.appendChild(opt);
                });
                voiceSelect.appendChild(optgroup);
            });

            if (!voiceFoundAndSet && voiceSelect.options.length > 0) {
                // Try to select first voice in OCR language group or English group
                let preferredOption = Array.from(voiceSelect.options).find(opt => {
                    const optLang = opt.getAttribute('data-lang').substring(0,2).toLowerCase();
                    return optLang === currentOcrLangPrefix || optLang === 'en';
                });
                if (preferredOption) {
                    preferredOption.selected = true;
                } else {
                    voiceSelect.options[0].selected = true; // Fallback to the very first option
                }
            }
            
            if(voiceSelect.options.length === 0) { // Should not happen if voices.length > 0
                const opt = document.createElement('option');
                opt.textContent = "No voices available after filtering";
                opt.disabled = true;
                voiceSelect.appendChild(opt);
                readBtn.disabled = true;
                previewVoiceBtn.disabled = true;
            }

        } catch (error) {
            console.error("Error populating voices:", error);
            updateStatus('Could not load voices. Speech synthesis might not be supported.', 'error');
            previewVoiceBtn.disabled = true;
            readBtn.disabled = true;
        }
    }

    document.addEventListener('DOMContentLoaded', async () => {
        loadPreferences();
        if (typeof speechSynthesis === 'undefined') {
            updateStatus('Speech Synthesis API is not supported. PDF reading is unavailable.', 'error');
            [previewVoiceBtn, speedRange, readBtn, pauseBtn, resumeBtn, stopBtn, voiceSelect, ocrLanguageSelect, clearPdfBtn, pdfFileInput].forEach(el => el.disabled = true);
            return;
        }
        
        // Voices can load asynchronously, so try populating a few times.
        populateVoices();
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = populateVoices;
        }
        // Additional attempt if voices are not immediately available
        setTimeout(populateVoices, 500); 
        setTimeout(populateVoices, 1500);


        await initializeTesseractWorker();

        readBtn.disabled = !pdfFileInput.files || !pdfFileInput.files[0];
        clearPdfBtn.disabled = !pdfFileInput.files || !pdfFileInput.files[0];
    });

    pdfFileInput.addEventListener('change', () => {
        const hasFile = pdfFileInput.files && pdfFileInput.files.length > 0;
        readBtn.disabled = !hasFile;
        clearPdfBtn.disabled = !hasFile;
        if (hasFile) {
            updateStatus(`File "${pdfFileInput.files[0].name}" selected. Click "Read PDF".`);
            resetReadingState(false);
            pdfViewContainer.innerHTML = '';
        } else {
            updateStatus('No file selected. Select a PDF and click "Read PDF".');
        }
    });
    
    ocrLanguageSelect.addEventListener('change', async () => {
        savePreferences();
        await initializeTesseractWorker(); // Re-initialize with new language
        populateVoices(); // Repopulate to re-prioritize voice groups based on new OCR lang
    });

    clearPdfBtn.addEventListener('click', () => {
        pdfFileInput.value = '';
        resetReadingState(true);
        updateStatus('PDF cleared. Select a new PDF file.');
        readBtn.disabled = true;
        clearPdfBtn.disabled = true;
    });

    function resetReadingState(fullReset = true) {
        speechSynthesis.cancel();
        isReading = false;
        readingQueue = [];
        pageChunkMap = [];
        currentChunkIndex = 0;
        // currentPdf = null; // Keep currentPdf if !fullReset and re-reading same doc? For now, it's cleared on new "Read PDF"
        if (fullReset) {
            pdfViewContainer.innerHTML = '';
            currentPdf = null;
        }
        pauseBtn.disabled = true;
        resumeBtn.disabled = true;
        stopBtn.disabled = true;
        readBtn.disabled = !(pdfFileInput.files && pdfFileInput.files.length > 0);
        removePageHighlight();
    }


    speedRange.addEventListener('input', () => {
      speedValue.textContent = parseFloat(speedRange.value).toFixed(1);
      savePreferences();
    });
    voiceSelect.addEventListener('change', savePreferences);


    previewVoiceBtn.addEventListener('click', () => {
      const selectedOption = voiceSelect.options[voiceSelect.selectedIndex];
      if (!selectedOption || !selectedOption.value || selectedOption.disabled) {
        updateStatus('Please select an available voice first.', 'error');
        return;
      }
      speechSynthesis.cancel();
      try {
        const preview = new SpeechSynthesisUtterance('This is a preview of the selected voice at the current speed.');
        preview.voice = voices.find(v => v.name === selectedOption.value); // Find by name
        if (!preview.voice) {
            updateStatus('Selected voice not found during preview. Try another.', 'error'); return;
        }
        preview.lang = preview.voice.lang; // Use the voice's specific language tag
        preview.rate  = parseFloat(speedRange.value);
        preview.onerror = (event) => {
            console.error('SpeechSynthesisUtterance error:', event.error);
            updateStatus(`Error previewing voice: ${event.error}`, 'error');
        };
        speechSynthesis.speak(preview);
      } catch (error) {
          console.error("Error in voice preview:", error);
          updateStatus(`Could not preview voice: ${error.message}`, 'error');
      }
    });

    readBtn.addEventListener('click', async () => {
      const file = pdfFileInput.files[0];
      if (!file) {
        updateStatus('🚫 Please select a PDF first.', 'error'); return;
      }
      const selectedVoiceOption = voiceSelect.options[voiceSelect.selectedIndex];
      if (!selectedVoiceOption || !selectedVoiceOption.value || selectedVoiceOption.disabled) {
        updateStatus('🚫 Please select an available voice.', 'error'); return;
      }
      if (!tesseractWorker) {
        updateStatus('🚫 OCR engine not initialized. Please wait or refresh.', 'error');
        await initializeTesseractWorker();
        if (!tesseractWorker) return;
      }

      resetReadingState(false);
      pdfViewContainer.innerHTML = '';
      currentPdf = null; // Ensure PDF is reloaded fully

      readBtn.disabled   = true;
      clearPdfBtn.disabled = true;

      updateStatus('Loading PDF…', 'processing');

      try {
        const data = await file.arrayBuffer();
        currentPdf = await pdfjsLib.getDocument({ data }).promise;
        const numPages = currentPdf.numPages;

        updateStatus(`Found ${numPages} page(s). Processing...`, 'processing');

        for (let i = 1; i <= numPages; i++) {
          const page = await currentPdf.getPage(i);
          const viewport = page.getViewport({ scale: 1.5 });
          const pageCanvas = document.createElement('canvas');
          pageCanvas.id = `pdfPageCanvas-${i}`;
          const pageCtx = pageCanvas.getContext('2d', { willReadFrequently: true });
          pdfViewContainer.appendChild(pageCanvas);

          pageCanvas.width = viewport.width;
          pageCanvas.height = viewport.height;
          pageCanvas.style.maxWidth = "100%";

          if (i === 1) pageCanvas.scrollIntoView({ behavior: 'auto', block: 'start' });

          await page.render({ canvasContext: pageCtx, viewport: viewport }).promise;
          updateStatus(`OCRing page ${i} of ${numPages}…`, 'processing');
          if(pageCanvas.scrollIntoViewIfNeeded) pageCanvas.scrollIntoViewIfNeeded({ behavior: 'smooth', block: 'nearest' });
          else pageCanvas.scrollIntoView({ behavior: 'smooth', block: 'nearest' });


          const { data: { text } } = await tesseractWorker.recognize(pageCanvas);
          const chunks = text.match(new RegExp(`(.|[\\r\\n]){1,250}(?=\\s|$)`, 'g'));
          if (chunks) {
            chunks.forEach(chunk => {
              if (chunk.trim().length >= MIN_CHUNK_LENGTH) {
                readingQueue.push(chunk.trim());
                pageChunkMap.push(i);
              }
            });
          }
        }

        if (!readingQueue.length) {
          updateStatus('⚠️ No text detected or extracted from the PDF.', 'error');
          readBtn.disabled = false;
          clearPdfBtn.disabled = false;
          return;
        }

        updateStatus('Text processed. Starting reading…', 'success');
        isReading = true;
        pauseBtn.disabled = false;
        stopBtn.disabled  = false;
        resumeBtn.disabled= true;
        speakNextChunk();

      } catch (error) {
        console.error("Error during PDF processing or OCR:", error);
        updateStatus(`🚫 Error: ${error.message}. Try again or check console.`, 'error');
        resetReadingState(false);
        readBtn.disabled = !(pdfFileInput.files && pdfFileInput.files.length > 0);
        clearPdfBtn.disabled = !(pdfFileInput.files && pdfFileInput.files.length > 0);
      }
    });

    function highlightCurrentPage(pageNumber) {
        removePageHighlight();
        const pageCanvas = document.getElementById(`pdfPageCanvas-${pageNumber}`);
        if (pageCanvas) {
            pageCanvas.classList.add('currentPageHighlight');
            if(pageCanvas.scrollIntoViewIfNeeded) pageCanvas.scrollIntoViewIfNeeded({ behavior: 'smooth', block: 'nearest' });
            else pageCanvas.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    }

    function removePageHighlight() {
        const highlighted = pdfViewContainer.querySelector('.currentPageHighlight');
        if (highlighted) {
            highlighted.classList.remove('currentPageHighlight');
        }
    }

    function speakNextChunk() {
      removePageHighlight();

      if (!isReading || currentChunkIndex >= readingQueue.length) {
        updateStatus(readingQueue.length > 0 ? '✅ Finished reading PDF.' : 'No text was queued.', 'success');
        resetReadingState(false);
        readBtn.disabled = !(pdfFileInput.files && pdfFileInput.files.length > 0);
        clearPdfBtn.disabled = !(pdfFileInput.files && pdfFileInput.files.length > 0);
        return;
      }

      let textToSpeak = readingQueue[currentChunkIndex];
      while (textToSpeak && textToSpeak.trim().length < MIN_CHUNK_LENGTH && currentChunkIndex < readingQueue.length -1) {
          currentChunkIndex++;
          textToSpeak = readingQueue[currentChunkIndex];
      }
       if (!textToSpeak || (textToSpeak.trim().length < MIN_CHUNK_LENGTH && currentChunkIndex >= readingQueue.length -1)) {
           speakNextChunk(); 
           return;
       }

      const currentPageNumber = pageChunkMap[currentChunkIndex];
      highlightCurrentPage(currentPageNumber);

      const utterance = new SpeechSynthesisUtterance(textToSpeak);
      const selectedVoiceOption = voiceSelect.options[voiceSelect.selectedIndex];
      
      if (selectedVoiceOption && selectedVoiceOption.value) {
          utterance.voice = voices.find(v => v.name === selectedVoiceOption.value);
      }

      if (!utterance.voice && voices.length > 0) {
        console.warn(`Selected voice "${selectedVoiceOption ? selectedVoiceOption.value : 'unknown'}" not fully matched or found, trying a default.`);
        // Try finding a voice matching the OCR language first
        const ocrLangPrefix = ocrLanguageSelect.value.substring(0,2).toLowerCase();
        utterance.voice = voices.find(v => v.lang.startsWith(ocrLangPrefix)) || voices.find(v => v.lang.startsWith('en')) || voices[0];
      }
      
      utterance.lang = utterance.voice ? utterance.voice.lang : (ocrLanguageSelect.value === 'eng' ? 'en-US' : ocrLanguageSelect.value);
      utterance.rate  = parseFloat(speedRange.value);


      utterance.onstart = () => {
        updateStatus(`Reading chunk ${currentChunkIndex + 1}/${readingQueue.length} from page ${currentPageNumber}…`, 'processing');
      };

      utterance.onend = () => {
        currentChunkIndex++;
        if (isReading) {
            speakNextChunk();
        } else {
            updateStatus('Reading stopped.', 'info');
            resetReadingState(false);
            readBtn.disabled = !(pdfFileInput.files && pdfFileInput.files.length > 0);
            clearPdfBtn.disabled = !(pdfFileInput.files && pdfFileInput.files.length > 0);
        }
      };

      utterance.onerror = (event) => {
        console.error('SpeechSynthesisUtterance error:', event.error, "Chunk:", textToSpeak);
        updateStatus(`Speech error: ${event.error}. Skipping chunk.`, 'error');
        currentChunkIndex++;
        if (isReading) speakNextChunk();
      };
      speechSynthesis.speak(utterance);
    }

    pauseBtn.addEventListener('click', () => {
      if (speechSynthesis.speaking && !speechSynthesis.paused) {
        speechSynthesis.pause();
        updateStatus('⏸ Paused.', 'processing');
        pauseBtn.disabled = true;
        resumeBtn.disabled= false;
        stopBtn.disabled  = false;
      }
    });

    resumeBtn.addEventListener('click', () => {
      if (speechSynthesis.paused) {
        speechSynthesis.resume();
        updateStatus('▶ Resuming…', 'processing');
        const currentPageNumber = pageChunkMap[currentChunkIndex]; // Re-highlight on resume
        if (currentPageNumber) highlightCurrentPage(currentPageNumber);
        pauseBtn.disabled = false;
        resumeBtn.disabled= true;
      }
    });

    stopBtn.addEventListener('click', () => {
      isReading = false;
      speechSynthesis.cancel();
      updateStatus('■ Stopped by user.', 'info');
      resetReadingState(false);
      readBtn.disabled = !(pdfFileInput.files && pdfFileInput.files.length > 0);
      clearPdfBtn.disabled = !(pdfFileInput.files && pdfFileInput.files.length > 0);
    });

    window.addEventListener('beforeunload', async () => {
        if (tesseractWorker) {
            console.log('Terminating Tesseract worker before page unload.');
            await tesseractWorker.terminate();
            tesseractWorker = null;
        }
        speechSynthesis.cancel();
    });

  </script>
</body>
</html>
